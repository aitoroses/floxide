<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <meta name="generator" content="mkdocs-1.6.1, mkdocs-terminal-4.7.0">
    
    <meta name="description" content="Documentation for the Floxide framework - A type-safe, composable directed graph workflow system written in Rust"> 
    
    <meta name="author" content="Floxide Team"> 
    <link rel="icon" type="image/png" sizes="192x192" href="../../img/android-chrome-192x192.png" />
<link rel="icon" type="image/png" sizes="512x512" href="../../img/android-chrome-512x512.png" />
<link rel="apple-touch-icon" sizes="180x180" href="../../img/apple-touch-icon.png" />
<link rel="shortcut icon" type="image/png" sizes="48x48" href="../../img/favicon.ico" />
<link rel="icon" type="image/png" sizes="16x16" href="../../img/favicon-16x16.png" />
<link rel="icon" type="image/png" sizes="32x32" href="../../img/favicon-32x32.png" />


    
 
<title>Chapter 4: Workflow Trait & workflow! Macro - Floxide Documentation</title>


<link href="../../css/fontawesome/css/fontawesome.min.css" rel="stylesheet">
<link href="../../css/fontawesome/css/solid.min.css" rel="stylesheet">
<link href="../../css/normalize.css" rel="stylesheet">
<link href="../../css/terminal.css" rel="stylesheet">
<link href="../../css/theme.css" rel="stylesheet">
<link href="../../css/theme.tile_grid.css" rel="stylesheet">
<link href="../../css/theme.footer.css" rel="stylesheet">
<!-- dark color palette -->
<link href="../../css/palettes/dark.css" rel="stylesheet">

<!-- page layout -->
<style>
/* initially set page layout to a one column grid */
.terminal-mkdocs-main-grid {
    display: grid;
    grid-column-gap: 1.4em;
    grid-template-columns: auto;
    grid-template-rows: auto;
}

/*  
*   when side navigation is not hidden, use a two column grid.  
*   if the screen is too narrow, fall back to the initial one column grid layout.
*   in this case the main content will be placed under the navigation panel. 
*/
@media only screen and (min-width: 70em) {
    .terminal-mkdocs-main-grid {
        grid-template-columns: 4fr 9fr;
    }
}</style>



    
    <link href="../../css/extra.css" rel="stylesheet">  
    
    

    
    <!-- search css support -->
<link href="../../css/search/bootstrap-modal.css" rel="stylesheet">
<!-- search scripts -->
<script>
    var base_url = "../..",
    shortcuts = "{}";
</script>
<script src="../../js/jquery/jquery-1.10.1.min.js" defer></script>
<script src="../../js/bootstrap/bootstrap.min.js" defer></script>
<script src="../../js/mkdocs/base.js" defer></script>
    
    
    
    
    <script src="https://unpkg.com/mermaid@10.6.1/dist/mermaid.min.js"></script>
    
    <script src="../../search/main.js"></script>
    

    
</head>

<body class="terminal"><div class="container">
    <div class="terminal-nav">
        <header class="terminal-logo">
            <div id="mkdocs-terminal-site-name" class="logo terminal-prompt"><a href="/" class="no-style">Floxide Documentation</a></div>
        </header>
        
        <nav class="terminal-menu">
            
            <ul vocab="https://schema.org/" typeof="BreadcrumbList">
                
                
                <li property="itemListElement" typeof="ListItem">
                    <a href="../.." class="menu-item " property="item" typeof="WebPage">
                        <span property="name">Home</span>
                    </a>
                    <meta property="position" content="0">
                </li>
                
                
                
                
                
                    
                    


<li property="itemListElement" typeof="ListItem">
    <a href="#" class="menu-item" data-toggle="modal" data-target="#mkdocs_search_modal" property="item" typeof="SearchAction">
        <i aria-hidden="true" class="fa fa-search"></i> <span property="name">Search</span>
    </a>
    <meta property="position" content="1">
</li>
                    
            </ul>
            
        </nav>
    </div>
</div>
        
    <div class="container">
        <div class="terminal-mkdocs-main-grid"><aside id="terminal-mkdocs-side-panel"><nav>
  
    <ul class="terminal-mkdocs-side-nav-items">
        
          



<li class="terminal-mkdocs-side-nav-li">
    
    
    
        
        
            <a class="

    terminal-mkdocs-side-nav-item" href="../..">Home</a>
        
    
    
    
  </li>
        
          



<li class="terminal-mkdocs-side-nav-li">
    
    
        
        

        
            
    
        
        
            
            
            <span class="
        
    

    terminal-mkdocs-side-nav-item terminal-mkdocs-side-nav-section-no-index">Core Concepts</span>
        
    
    
        
      
        
            <ul class="terminal-mkdocs-side-nav-li-ul">
        
            
            

             
                <li class="terminal-mkdocs-side-nav-li-ul-li">
    
        
        
            <a class="

    terminal-mkdocs-side-nav-item" href="../../core-concepts/">Overview</a>
        
    
    </li>
            
            
    </ul>
        
    
  </li>
        
          



<li class="terminal-mkdocs-side-nav-li">
    
    
        
        

        
            
    
        
        <span class="
        
    

    terminal-mkdocs-side-nav-item--active terminal-mkdocs-side-nav-section-no-index">Tutorial</span>
    
    
        
      
        
            <ul class="terminal-mkdocs-side-nav-li-ul">
        
            
            

             
                <li class="terminal-mkdocs-side-nav-li-ul-li">
    
        
        
            <a class="

    terminal-mkdocs-side-nav-item" href="../">Introduction</a>
        
    
    </li>
            
        
            
            

             
                <li class="terminal-mkdocs-side-nav-li-ul-li">
    
        
        
            <a class="

    terminal-mkdocs-side-nav-item" href="../01__transition__enum_/">Chapter 1: Transition Enum</a>
        
    
    </li>
            
        
            
            

             
                <li class="terminal-mkdocs-side-nav-li-ul-li">
    
        
        
            <a class="

    terminal-mkdocs-side-nav-item" href="../02__node__trait____node___macro_/">Chapter 2: Node Trait & node! Macro</a>
        
    
    </li>
            
        
            
            

             
                <li class="terminal-mkdocs-side-nav-li-ul-li">
    
        
        
            <a class="

    terminal-mkdocs-side-nav-item" href="../03__workflowctx_____context__trait_/">Chapter 3: WorkflowCtx & Context Trait</a>
        
    
    </li>
            
        
            
            

             
                <li class="terminal-mkdocs-side-nav-li-ul-li">
    
        
        <span class="

    terminal-mkdocs-side-nav-item--active">Chapter 4: Workflow Trait & workflow! Macro</span>
    
    </li>
            
        
            
            

             
                <li class="terminal-mkdocs-side-nav-li-ul-li">
    
        
        
            <a class="

    terminal-mkdocs-side-nav-item" href="../05__workqueue__trait_/">Chapter 5: WorkQueue Trait</a>
        
    
    </li>
            
        
            
            

             
                <li class="terminal-mkdocs-side-nav-li-ul-li">
    
        
        
            <a class="

    terminal-mkdocs-side-nav-item" href="../06__checkpoint_____checkpointstore__trait_/">Chapter 6: Checkpoint & CheckpointStore Trait</a>
        
    
    </li>
            
        
            
            

             
                <li class="terminal-mkdocs-side-nav-li-ul-li">
    
        
        
            <a class="

    terminal-mkdocs-side-nav-item" href="../07__distributedworker__/">Chapter 7: DistributedWorker</a>
        
    
    </li>
            
        
            
            

             
                <li class="terminal-mkdocs-side-nav-li-ul-li">
    
        
        
            <a class="

    terminal-mkdocs-side-nav-item" href="../08__distributedorchestrator__/">Chapter 8: DistributedOrchestrator</a>
        
    
    </li>
            
        
            
            

             
                <li class="terminal-mkdocs-side-nav-li-ul-li">
    
        
        
            <a class="

    terminal-mkdocs-side-nav-item" href="../09_distributed_stores___runinfostore____metricsstore____errorstore____livenessstore____workitemstatestore___/">Chapter 9: Distributed Stores</a>
        
    
    </li>
            
        
            
            

             
                <li class="terminal-mkdocs-side-nav-li-ul-li">
    
        
        
            <a class="

    terminal-mkdocs-side-nav-item" href="../10__retrypolicy_____retrynode__/">Chapter 10: RetryPolicy & RetryNode</a>
        
    
    </li>
            
            
    </ul>
        
    
  </li>
        
    </ul>
  
</nav><hr>
<nav>
    <ul>
        <li><a href="#chapter-4-workflow-trait-workflow-macro">Chapter 4: Workflow Trait &amp; workflow! Macro</a></li>
        <li><a href="#whats-the-problem-defining-the-assembly-line-layout">What's the Problem? Defining the Assembly Line Layout</a></li><li><a href="#what-is-a-workflow">What is a Workflow?</a></li><li><a href="#the-workflow-trait-the-contract">The Workflow Trait: The Contract</a></li><li><a href="#the-workflow-macro-your-workflow-designer">The workflow! Macro: Your Workflow Designer</a></li><li><a href="#example-a-simple-text-processing-workflow">Example: A Simple Text Processing Workflow</a></li><li><a href="#under-the-hood-what-does-workflow-generate">Under the Hood: What Does workflow! Generate?</a></li><li><a href="#conclusion">Conclusion</a></li>
    </ul>
</nav>
</aside>
            <main id="terminal-mkdocs-main-content">
<section id="mkdocs-terminal-content">
    <h1 id="chapter-4-workflow-trait-workflow-macro">Chapter 4: <code>Workflow</code> Trait &amp; <code>workflow!</code> Macro<a class="headerlink" href="#chapter-4-workflow-trait-workflow-macro" title="Permanent link">&para;</a></h1>
<p>In the <a href="../03__workflowctx_____context__trait_/">previous chapter</a>, we learned how individual steps (<a href="../02__node__trait____node___macro_/"><code>Node</code>s</a>) can share information using <code>WorkflowCtx</code> and the <code>Context</code> trait. We now have building blocks (Nodes) and a way to share data (Context). But how do we connect these blocks together to form a complete process? How does Floxide know that after Node A finishes, Node B should start? Especially when these nodes might be running on different computers?</p>
<h2 id="whats-the-problem-defining-the-assembly-line-layout">What's the Problem? Defining the Assembly Line Layout<a class="headerlink" href="#whats-the-problem-defining-the-assembly-line-layout" title="Permanent link">&para;</a></h2>
<p>Imagine you have designed all the individual stations (<code>Node</code>s) for your assembly line (like "Download Video", "Extract Audio", "Upload Result"). You also have a way for workers at these stations to access shared tools or instructions (<code>Context</code>). Now, you need the master blueprint that shows:</p>
<ol>
<li>Which station is the <em>first</em> one?</li>
<li>When station A finishes successfully, which station(s) should the item go to next?</li>
<li>What if station A produces multiple items (<a href="../01__transition__enum_/"><code>Transition::NextAll</code></a>)? Where do they all go?</li>
<li>What if station A fails or needs special handling (<a href="../01__transition__enum_/"><code>Transition::Abort</code></a>)? Is there a fallback path?</li>
<li>How does the whole system know when the <em>entire</em> process is finished?</li>
</ol>
<p>This blueprint is crucial, especially in a <strong>distributed</strong> system. Without a clear map, how would a worker on computer X know that the output it just produced needs to be picked up by a worker on computer Y running the next step?</p>
<p>Floxide uses the <strong><code>Workflow</code></strong> concept to represent this master blueprint.</p>
<h2 id="what-is-a-workflow">What is a <code>Workflow</code>?<a class="headerlink" href="#what-is-a-workflow" title="Permanent link">&para;</a></h2>
<p>A <code>Workflow</code> in Floxide defines the complete structure and flow of tasks. It's the top-level container that holds all the individual <a href="../02__node__trait____node___macro_/"><code>Node</code>s</a> and specifies exactly how they are connected (the "edges" between them).</p>
<p>Key responsibilities of a Workflow definition:</p>
<ul>
<li><strong>Contains Nodes:</strong> Holds instances of all the Node structs that make up the workflow.</li>
<li><strong>Specifies Start:</strong> Declares which Node is the entry point.</li>
<li><strong>Defines Context:</strong> Specifies the type of shared <a href="../03__workflowctx_____context__trait_/"><code>Context</code></a> the workflow uses.</li>
<li><strong>Maps Connections (Edges):</strong> Explicitly defines the paths between Nodes. This includes:<ul>
<li>Simple connections: Output of Node A goes to Node B.</li>
<li>Fan-out: Output of Node A goes to Node B <em>and</em> Node C.</li>
<li>Conditional branching: If Node A returns variant X, go to Node B; if it returns variant Y, go to Node C.</li>
<li>Fallback paths: If Node A fails, maybe trigger Node F (e.g., an error handler).</li>
</ul>
</li>
<li><strong>Identifies End:</strong> Implicitly defines the terminal Node(s) â€“ those with no further connections.</li>
</ul>
<h2 id="the-workflow-trait-the-contract">The <code>Workflow</code> Trait: The Contract<a class="headerlink" href="#the-workflow-trait-the-contract" title="Permanent link">&para;</a></h2>
<p>Like the <code>Node</code> trait, Floxide uses a <code>Workflow</code> trait to define the standard capabilities expected of any workflow structure. This trait ensures that the Floxide engine knows how to interact with your workflow definition, regardless of how complex it is.</p>
<p>Some key methods defined by the <code>Workflow</code> trait (simplified concept):</p>
<div class="language-rust highlight"><pre><span></span><code><span id="__span-0-1"><span class="c1">// Simplified concept from floxide-core/src/workflow.rs</span>
</span><span id="__span-0-2"><span class="cp">#[async_trait]</span>
</span><span id="__span-0-3"><span class="k">trait</span><span class="w"> </span><span class="n">Workflow</span><span class="o">&lt;</span><span class="n">C</span><span class="p">:</span><span class="w"> </span><span class="nc">Context</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
</span><span id="__span-0-4"><span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="nc">Input</span><span class="p">;</span><span class="w">  </span><span class="c1">// Data type the *start* node expects</span>
</span><span id="__span-0-5"><span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="nc">Output</span><span class="p">;</span><span class="w"> </span><span class="c1">// Data type the *terminal* node produces</span>
</span><span id="__span-0-6"><span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="nc">WorkItem</span><span class="p">;</span><span class="w"> </span><span class="c1">// An internal type representing a task (Node + Input)</span>
</span><span id="__span-0-7">
</span><span id="__span-0-8"><span class="w">    </span><span class="c1">// Run the whole workflow locally</span>
</span><span id="__span-0-9"><span class="w">    </span><span class="k">async</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">run</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">ctx</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">WorkflowCtx</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">input</span><span class="p">:</span><span class="w"> </span><span class="nc">Self</span><span class="p">::</span><span class="n">Input</span><span class="p">)</span>
</span><span id="__span-0-10"><span class="w">        </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="bp">Self</span><span class="p">::</span><span class="n">Output</span><span class="p">,</span><span class="w"> </span><span class="n">FloxideError</span><span class="o">&gt;</span><span class="p">;</span>
</span><span id="__span-0-11">
</span><span id="__span-0-12"><span class="w">    </span><span class="c1">// Run with saving state after each step</span>
</span><span id="__span-0-13"><span class="w">    </span><span class="k">async</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">run_with_checkpoint</span><span class="o">&lt;</span><span class="n">CS</span><span class="o">&gt;</span><span class="p">(</span><span class="o">..</span><span class="p">.)</span>
</span><span id="__span-0-14"><span class="w">        </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="bp">Self</span><span class="p">::</span><span class="n">Output</span><span class="p">,</span><span class="w"> </span><span class="n">FloxideError</span><span class="o">&gt;</span><span class="p">;</span>
</span><span id="__span-0-15">
</span><span id="__span-0-16"><span class="w">    </span><span class="c1">// Resume from a saved state</span>
</span><span id="__span-0-17"><span class="w">    </span><span class="k">async</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">resume</span><span class="o">&lt;</span><span class="n">CS</span><span class="o">&gt;</span><span class="p">(</span><span class="o">..</span><span class="p">.)</span>
</span><span id="__span-0-18"><span class="w">        </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="bp">Self</span><span class="p">::</span><span class="n">Output</span><span class="p">,</span><span class="w"> </span><span class="n">FloxideError</span><span class="o">&gt;</span><span class="p">;</span>
</span><span id="__span-0-19">
</span><span id="__span-0-20"><span class="w">    </span><span class="c1">// --- Distributed Primitives ---</span>
</span><span id="__span-0-21">
</span><span id="__span-0-22"><span class="w">    </span><span class="c1">// Prepare a distributed run (Orchestrator)</span>
</span><span id="__span-0-23"><span class="w">    </span><span class="k">async</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">start_distributed</span><span class="o">&lt;</span><span class="n">CS</span><span class="p">,</span><span class="w"> </span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">..</span><span class="p">.)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">FloxideError</span><span class="o">&gt;</span><span class="p">;</span>
</span><span id="__span-0-24">
</span><span id="__span-0-25"><span class="w">    </span><span class="c1">// Execute one step in a distributed run (Worker)</span>
</span><span id="__span-0-26"><span class="w">    </span><span class="k">async</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">step_distributed</span><span class="o">&lt;</span><span class="n">CS</span><span class="p">,</span><span class="w"> </span><span class="n">Q</span><span class="o">&gt;</span><span class="p">(</span><span class="o">..</span><span class="p">.)</span>
</span><span id="__span-0-27"><span class="w">        </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="bp">Self</span><span class="p">::</span><span class="n">Output</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">StepError</span><span class="o">&lt;</span><span class="bp">Self</span><span class="p">::</span><span class="n">WorkItem</span><span class="o">&gt;&gt;</span><span class="p">;</span>
</span><span id="__span-0-28">
</span><span id="__span-0-29"><span class="w">    </span><span class="c1">// Process a single WorkItem (Internal helper for routing)</span>
</span><span id="__span-0-30"><span class="w">    </span><span class="k">async</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">process_work_item</span><span class="p">(</span><span class="o">..</span><span class="p">.)</span>
</span><span id="__span-0-31"><span class="w">        </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="bp">Self</span><span class="p">::</span><span class="n">Output</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">FloxideError</span><span class="o">&gt;</span><span class="p">;</span>
</span><span id="__span-0-32">
</span><span id="__span-0-33"><span class="w">    </span><span class="c1">// Get a visual representation</span>
</span><span id="__span-0-34"><span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">to_dot</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kp">&amp;</span><span class="o">&#39;</span><span class="nb">static</span><span class="w"> </span><span class="kt">str</span><span class="p">;</span>
</span><span id="__span-0-35"><span class="p">}</span>
</span></code></pre></div>
<p>This trait provides methods for different execution modes: simple local runs (<code>run</code>), resumable runs (<code>run_with_checkpoint</code>, <code>resume</code>), and the core primitives for <strong>distributed</strong> execution (<code>start_distributed</code>, <code>step_distributed</code>). The <code>process_work_item</code> method is crucial internally for handling the routing logic based on the defined edges.</p>
<p>Manually implementing this trait would be very complex! Thankfully, Floxide provides a macro to do the heavy lifting.</p>
<h2 id="the-workflow-macro-your-workflow-designer">The <code>workflow!</code> Macro: Your Workflow Designer<a class="headerlink" href="#the-workflow-macro-your-workflow-designer" title="Permanent link">&para;</a></h2>
<p>The <code>workflow!</code> macro is the high-level tool you'll use to define your workflow's structure. It takes care of generating the necessary struct, the internal <code>WorkItem</code> enum (which tracks which node needs to run with what data), and the implementation of the <code>Workflow</code> trait, including all the complex routing logic.</p>
<p>Here's the basic syntax:</p>
<div class="language-rust highlight"><pre><span></span><code><span id="__span-1-1"><span class="c1">// General syntax of the workflow! macro</span>
</span><span id="__span-1-2"><span class="n">workflow</span><span class="o">!</span><span class="w"> </span><span class="p">{</span>
</span><span id="__span-1-3"><span class="w">  </span><span class="c1">// 1. Define the struct holding the Nodes</span>
</span><span id="__span-1-4"><span class="w">  </span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">MyWorkflow</span><span class="w"> </span><span class="p">{</span>
</span><span id="__span-1-5"><span class="w">    </span><span class="c1">// Fields are instances of your Nodes</span>
</span><span id="__span-1-6"><span class="w">    </span><span class="n">step_a</span><span class="p">:</span><span class="w"> </span><span class="nc">NodeAInstance</span><span class="p">,</span>
</span><span id="__span-1-7"><span class="w">    </span><span class="n">step_b</span><span class="p">:</span><span class="w"> </span><span class="nc">NodeBInstance</span><span class="p">,</span>
</span><span id="__span-1-8"><span class="w">    </span><span class="n">step_c</span><span class="p">:</span><span class="w"> </span><span class="nc">NodeCInstance</span><span class="p">,</span>
</span><span id="__span-1-9"><span class="w">    </span><span class="c1">// You can also include retry policies here if needed</span>
</span><span id="__span-1-10"><span class="w">    </span><span class="c1">// retry_policy: MyRetryPolicy,</span>
</span><span id="__span-1-11"><span class="w">  </span><span class="p">}</span>
</span><span id="__span-1-12"><span class="w">  </span><span class="c1">// 2. Specify the Context type</span>
</span><span id="__span-1-13"><span class="w">  </span><span class="n">context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MyWorkflowContext</span><span class="p">;</span>
</span><span id="__span-1-14"><span class="w">  </span><span class="c1">// 3. Specify the starting Node field</span>
</span><span id="__span-1-15"><span class="w">  </span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">step_a</span><span class="p">;</span>
</span><span id="__span-1-16"><span class="w">  </span><span class="c1">// 4. Define the connections (edges)</span>
</span><span id="__span-1-17"><span class="w">  </span><span class="n">edges</span><span class="w"> </span><span class="p">{</span>
</span><span id="__span-1-18"><span class="w">    </span><span class="c1">// If step_a succeeds, its output goes to step_b</span>
</span><span id="__span-1-19"><span class="w">    </span><span class="n">step_a</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">step_b</span><span class="p">];</span>
</span><span id="__span-1-20">
</span><span id="__span-1-21"><span class="w">    </span><span class="c1">// If step_b succeeds, its output goes to step_c</span>
</span><span id="__span-1-22"><span class="w">    </span><span class="c1">// (Example: can also have conditional or fallback edges)</span>
</span><span id="__span-1-23"><span class="w">    </span><span class="n">step_b</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">step_c</span><span class="p">];</span>
</span><span id="__span-1-24">
</span><span id="__span-1-25"><span class="w">    </span><span class="c1">// step_c is the last step (terminal node)</span>
</span><span id="__span-1-26"><span class="w">    </span><span class="n">step_c</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">[];</span><span class="w"> </span><span class="c1">// Empty list means it&#39;s an end point</span>
</span><span id="__span-1-27"><span class="w">  </span><span class="p">};</span>
</span><span id="__span-1-28"><span class="p">}</span>
</span></code></pre></div>
<p>Let's break it down:</p>
<ol>
<li><strong>Struct Definition:</strong> <code>pub struct MyWorkflow { ... }</code> defines a struct that will hold instances of your <a href="../02__node__trait____node___macro_/"><code>Node</code>s</a>. Give each Node instance a field name (e.g., <code>step_a</code>, <code>step_b</code>).</li>
<li><strong><code>context = Type;</code></strong>: Specifies the shared <a href="../03__workflowctx_____context__trait_/"><code>Context</code></a> type this workflow uses (e.g., <code>MyWorkflowData</code> from Chapter 3).</li>
<li><strong><code>start = field_name;</code></strong>: Tells Floxide which field in your struct represents the first Node to execute (e.g., <code>step_a</code>).</li>
<li><strong><code>edges { ... };</code></strong>: This is the core mapping section.<ul>
<li><code>source_field =&gt; [target_field_1, target_field_2, ...];</code> defines where the output of the <code>source_field</code> Node should go upon successful completion (<a href="../01__transition__enum_/"><code>Transition::Next</code></a> or <a href="../01__transition__enum_/"><code>Transition::NextAll</code></a>). An empty list <code>[]</code> means this Node is a terminal point.</li>
<li>(Advanced: The macro also supports conditional branching based on Node output variants and fallback paths using <code>on_failure</code>, but we'll stick to simple cases here).</li>
</ul>
</li>
</ol>
<h2 id="example-a-simple-text-processing-workflow">Example: A Simple Text Processing Workflow<a class="headerlink" href="#example-a-simple-text-processing-workflow" title="Permanent link">&para;</a></h2>
<p>Let's combine the Nodes from Chapter 2 into a simple workflow: <code>PrefixAndCapitalizeNode</code> -&gt; <code>CapitalizeTextNode</code>.</p>
<div class="language-rust highlight"><pre><span></span><code><span id="__span-2-1"><span class="k">use</span><span class="w"> </span><span class="n">floxide</span><span class="p">::{</span><span class="n">workflow</span><span class="p">,</span><span class="w"> </span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="n">Workflow</span><span class="p">,</span><span class="w"> </span><span class="n">Node</span><span class="p">,</span><span class="w"> </span><span class="n">Context</span><span class="p">,</span><span class="w"> </span><span class="n">Transition</span><span class="p">,</span><span class="w"> </span><span class="n">FloxideError</span><span class="p">};</span>
</span><span id="__span-2-2"><span class="k">use</span><span class="w"> </span><span class="n">serde</span><span class="p">::{</span><span class="n">Serialize</span><span class="p">,</span><span class="w"> </span><span class="n">Deserialize</span><span class="p">};</span>
</span><span id="__span-2-3"><span class="k">use</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">sync</span><span class="p">::</span><span class="n">Arc</span><span class="p">;</span><span class="w"> </span><span class="c1">// Needed for callbacks in distributed step</span>
</span><span id="__span-2-4">
</span><span id="__span-2-5"><span class="c1">// --- Define Context (from Chapter 3) ---</span>
</span><span id="__span-2-6"><span class="cp">#[derive(Clone, Debug, Default, Serialize, Deserialize)]</span>
</span><span id="__span-2-7"><span class="k">struct</span><span class="w"> </span><span class="nc">SimpleContext</span><span class="w"> </span><span class="p">{}</span>
</span><span id="__span-2-8"><span class="c1">// No need for `impl Context for SimpleContext {}` if deriving required traits</span>
</span><span id="__span-2-9">
</span><span id="__span-2-10"><span class="c1">// --- Define Nodes (from Chapter 2, simplified) ---</span>
</span><span id="__span-2-11"><span class="n">node</span><span class="o">!</span><span class="w"> </span><span class="p">{</span>
</span><span id="__span-2-12"><span class="w">  </span><span class="cp">#[derive(Clone, Debug)]</span><span class="w"> </span><span class="c1">// Add Clone/Debug</span>
</span><span id="__span-2-13"><span class="w">  </span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">PrefixNode</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">prefix</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="w"> </span><span class="p">}</span>
</span><span id="__span-2-14"><span class="w">  </span><span class="n">context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SimpleContext</span><span class="p">;</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span><span class="p">;</span><span class="w"> </span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span><span class="p">;</span>
</span><span id="__span-2-15"><span class="w">  </span><span class="o">|</span><span class="n">ctx</span><span class="p">,</span><span class="w"> </span><span class="n">text</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
</span><span id="__span-2-16"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">format!</span><span class="p">(</span><span class="s">&quot;{}: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="n">text</span><span class="p">);</span>
</span><span id="__span-2-17"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;PrefixNode: {} -&gt; {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">text</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">);</span>
</span><span id="__span-2-18"><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">Transition</span><span class="p">::</span><span class="n">Next</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
</span><span id="__span-2-19"><span class="w">  </span><span class="p">}</span>
</span><span id="__span-2-20"><span class="p">}</span>
</span><span id="__span-2-21">
</span><span id="__span-2-22"><span class="n">node</span><span class="o">!</span><span class="w"> </span><span class="p">{</span>
</span><span id="__span-2-23"><span class="w">  </span><span class="cp">#[derive(Clone, Debug)]</span><span class="w"> </span><span class="c1">// Add Clone/Debug</span>
</span><span id="__span-2-24"><span class="w">  </span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">CapitalizeNode</span><span class="w"> </span><span class="p">{}</span>
</span><span id="__span-2-25"><span class="w">  </span><span class="n">context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SimpleContext</span><span class="p">;</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span><span class="p">;</span><span class="w"> </span><span class="n">output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span><span class="p">;</span>
</span><span id="__span-2-26"><span class="w">  </span><span class="o">|</span><span class="n">ctx</span><span class="p">,</span><span class="w"> </span><span class="n">text</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
</span><span id="__span-2-27"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">text</span><span class="p">.</span><span class="n">to_uppercase</span><span class="p">();</span>
</span><span id="__span-2-28"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;CapitalizeNode: {} -&gt; {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">text</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">);</span>
</span><span id="__span-2-29"><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">Transition</span><span class="p">::</span><span class="n">Next</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
</span><span id="__span-2-30"><span class="w">  </span><span class="p">}</span>
</span><span id="__span-2-31"><span class="p">}</span>
</span><span id="__span-2-32">
</span><span id="__span-2-33"><span class="c1">// --- Define the Workflow using the workflow! macro ---</span>
</span><span id="__span-2-34"><span class="n">workflow</span><span class="o">!</span><span class="w"> </span><span class="p">{</span>
</span><span id="__span-2-35"><span class="w">  </span><span class="c1">// Struct holds instances of our nodes</span>
</span><span id="__span-2-36"><span class="w">  </span><span class="cp">#[derive(Clone, Debug)]</span><span class="w"> </span><span class="c1">// Workflow struct should also be Clone/Debug</span>
</span><span id="__span-2-37"><span class="w">  </span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">TextProcessor</span><span class="w"> </span><span class="p">{</span>
</span><span id="__span-2-38"><span class="w">    </span><span class="n">add_prefix</span><span class="p">:</span><span class="w"> </span><span class="nc">PrefixNode</span><span class="p">,</span><span class="w"> </span><span class="c1">// Instance of PrefixNode</span>
</span><span id="__span-2-39"><span class="w">    </span><span class="n">capitalize</span><span class="p">:</span><span class="w"> </span><span class="nc">CapitalizeNode</span><span class="p">,</span><span class="w"> </span><span class="c1">// Instance of CapitalizeNode</span>
</span><span id="__span-2-40"><span class="w">  </span><span class="p">}</span>
</span><span id="__span-2-41"><span class="w">  </span><span class="c1">// Use our simple context</span>
</span><span id="__span-2-42"><span class="w">  </span><span class="n">context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SimpleContext</span><span class="p">;</span>
</span><span id="__span-2-43"><span class="w">  </span><span class="c1">// Start with the &#39;add_prefix&#39; node</span>
</span><span id="__span-2-44"><span class="w">  </span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">add_prefix</span><span class="p">;</span>
</span><span id="__span-2-45"><span class="w">  </span><span class="c1">// Define the flow: add_prefix -&gt; capitalize -&gt; end</span>
</span><span id="__span-2-46"><span class="w">  </span><span class="n">edges</span><span class="w"> </span><span class="p">{</span>
</span><span id="__span-2-47"><span class="w">    </span><span class="n">add_prefix</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">capitalize</span><span class="p">];</span><span class="w"> </span><span class="c1">// Output of add_prefix goes to capitalize</span>
</span><span id="__span-2-48"><span class="w">    </span><span class="n">capitalize</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">[];</span><span class="w">          </span><span class="c1">// capitalize is the terminal node</span>
</span><span id="__span-2-49"><span class="w">  </span><span class="p">};</span>
</span><span id="__span-2-50"><span class="p">}</span>
</span><span id="__span-2-51">
</span><span id="__span-2-52"><span class="c1">// --- How you might use it (conceptual) ---</span>
</span><span id="__span-2-53"><span class="c1">// #[tokio::main]</span>
</span><span id="__span-2-54"><span class="c1">// async fn main() -&gt; Result&lt;(), FloxideError&gt; {</span>
</span><span id="__span-2-55"><span class="c1">//     // 1. Create instances of the Nodes</span>
</span><span id="__span-2-56"><span class="c1">//     let prefixer = PrefixNode { prefix: &quot;INFO&quot;.to_string() };</span>
</span><span id="__span-2-57"><span class="c1">//     let capitalizer = CapitalizeNode {};</span>
</span><span id="__span-2-58"><span class="c1">//</span>
</span><span id="__span-2-59"><span class="c1">//     // 2. Create an instance of the Workflow struct</span>
</span><span id="__span-2-60"><span class="c1">//     let my_workflow = TextProcessor {</span>
</span><span id="__span-2-61"><span class="c1">//         add_prefix: prefixer,</span>
</span><span id="__span-2-62"><span class="c1">//         capitalize: capitalizer,</span>
</span><span id="__span-2-63"><span class="c1">//     };</span>
</span><span id="__span-2-64"><span class="c1">//</span>
</span><span id="__span-2-65"><span class="c1">//     // 3. Create the initial context</span>
</span><span id="__span-2-66"><span class="c1">//     let initial_context_data = SimpleContext {};</span>
</span><span id="__span-2-67"><span class="c1">//     let wf_ctx = floxide::WorkflowCtx::new(initial_context_data);</span>
</span><span id="__span-2-68"><span class="c1">//</span>
</span><span id="__span-2-69"><span class="c1">//     // 4. Run the workflow (using the &#39;run&#39; method from the Workflow trait)</span>
</span><span id="__span-2-70"><span class="c1">//     let input_text = &quot;hello world&quot;.to_string();</span>
</span><span id="__span-2-71"><span class="c1">//     println!(&quot;Starting workflow with input: &#39;{}&#39;&quot;, input_text);</span>
</span><span id="__span-2-72"><span class="c1">//     let final_result = my_workflow.run(&amp;wf_ctx, input_text).await?;</span>
</span><span id="__span-2-73"><span class="c1">//</span>
</span><span id="__span-2-74"><span class="c1">//     println!(&quot;Workflow finished. Final result: &#39;{}&#39;&quot;, final_result);</span>
</span><span id="__span-2-75"><span class="c1">//     // Expected output:</span>
</span><span id="__span-2-76"><span class="c1">//     // Starting workflow with input: &#39;hello world&#39;</span>
</span><span id="__span-2-77"><span class="c1">//     // PrefixNode: hello world -&gt; INFO: hello world</span>
</span><span id="__span-2-78"><span class="c1">//     // CapitalizeNode: INFO: hello world -&gt; INFO: HELLO WORLD</span>
</span><span id="__span-2-79"><span class="c1">//     // Workflow finished. Final result: &#39;INFO: HELLO WORLD&#39;</span>
</span><span id="__span-2-80"><span class="c1">//</span>
</span><span id="__span-2-81"><span class="c1">//     Ok(())</span>
</span><span id="__span-2-82"><span class="c1">// }</span>
</span></code></pre></div>
<p><strong>Explanation:</strong></p>
<ol>
<li>We defined our <code>SimpleContext</code> and two Nodes (<code>PrefixNode</code>, <code>CapitalizeNode</code>).</li>
<li>We used <code>workflow!</code> to define <code>TextProcessor</code>.<ul>
<li>The struct holds fields <code>add_prefix</code> and <code>capitalize</code>.</li>
<li>We set <code>context = SimpleContext</code>.</li>
<li>We set <code>start = add_prefix</code>.</li>
<li>In <code>edges</code>, we defined <code>add_prefix =&gt; [capitalize];</code> (output of <code>add_prefix</code> goes to <code>capitalize</code>) and <code>capitalize =&gt; [];</code> ( <code>capitalize</code> is the end).</li>
</ul>
</li>
<li>In the conceptual usage:<ul>
<li>We create instances of the Nodes and the <code>TextProcessor</code> workflow struct.</li>
<li>We create the initial <a href="../03__workflowctx_____context__trait_/"><code>WorkflowCtx</code></a>.</li>
<li>We call the <code>run</code> method (which the <code>workflow!</code> macro generated for us!) with the context and initial input.</li>
<li>The macro-generated code handles calling <code>add_prefix</code>, taking its output, calling <code>capitalize</code> with that output, and finally returning the result from <code>capitalize</code> because it's the terminal node.</li>
</ul>
</li>
</ol>
<p><strong>Distributed Emphasis:</strong> If we were running this distributed (using <code>start_distributed</code> and <code>step_distributed</code>), the <code>edges</code> definition is absolutely critical. When <code>add_prefix</code> finishes on Worker 1, the macro-generated <code>process_work_item</code> logic consults the <code>edges</code>. It sees that <code>capitalize</code> is next. It then wraps the output of <code>add_prefix</code> into a <code>WorkItem</code> representing the <code>capitalize</code> task and places it onto the shared <a href="../05__workqueue__trait_/"><code>WorkQueue</code></a>. Worker 2 (or maybe even Worker 1 again later) can then pick up this <code>capitalize</code> task from the queue and execute it. The <code>workflow!</code> macro essentially compiles your visual blueprint into executable routing logic.</p>
<h2 id="under-the-hood-what-does-workflow-generate">Under the Hood: What Does <code>workflow!</code> Generate?<a class="headerlink" href="#under-the-hood-what-does-workflow-generate" title="Permanent link">&para;</a></h2>
<p>The <code>workflow!</code> macro is a code generator. It takes your high-level definition and expands it into more detailed Rust code, saving you from writing a lot of boilerplate.</p>
<ol>
<li><strong>Workflow Struct:</strong> It generates the struct you defined (e.g., <code>pub struct TextProcessor { ... }</code>).</li>
<li><strong><code>WorkItem</code> Enum:</strong> It creates a hidden helper enum (e.g., <code>TextProcessorWorkItem</code>). This enum has one variant for each Node field in your workflow struct. This enum is how Floxide keeps track of "what work needs to be done next".
    <div class="language-rust highlight"><pre><span></span><code><span id="__span-3-1"><span class="c1">// Simplified generated code (conceptual)</span>
</span><span id="__span-3-2"><span class="cp">#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]</span>
</span><span id="__span-3-3"><span class="k">enum</span><span class="w"> </span><span class="nc">TextProcessorWorkItem</span><span class="w"> </span><span class="p">{</span>
</span><span id="__span-3-4"><span class="w">    </span><span class="n">AddPrefix</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span><span class="w"> </span><span class="c1">// Carries input for PrefixNode</span>
</span><span id="__span-3-5"><span class="w">    </span><span class="n">Capitalize</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span><span class="w"> </span><span class="c1">// Carries input for CapitalizeNode</span>
</span><span id="__span-3-6"><span class="p">}</span>
</span><span id="__span-3-7"><span class="c1">// Also implements Display for unique IDs, needed for WorkItem trait</span>
</span><span id="__span-3-8"><span class="k">impl</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">fmt</span><span class="p">::</span><span class="n">Display</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">TextProcessorWorkItem</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* ... */</span><span class="w"> </span><span class="p">}</span>
</span><span id="__span-3-9"><span class="k">impl</span><span class="w"> </span><span class="n">floxide_core</span><span class="p">::</span><span class="n">workflow</span><span class="p">::</span><span class="n">WorkItem</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">TextProcessorWorkItem</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* ... */</span><span class="w"> </span><span class="p">}</span>
</span></code></pre></div></li>
<li><strong><code>impl Workflow</code>:</strong> It generates the implementation of the <a href="./"><code>Workflow</code></a> trait for your struct (<code>impl Workflow&lt;SimpleContext&gt; for TextProcessor { ... }</code>). This implementation includes:<ul>
<li>Definitions for <code>Input</code>, <code>Output</code>, and <code>WorkItem</code> associated types.</li>
<li>Implementations for <code>run</code>, <code>run_with_checkpoint</code>, <code>resume</code>, <code>start_distributed</code>, <code>step_distributed</code>, and <code>to_dot</code>.</li>
<li>The <strong>crucial <code>process_work_item</code> method</strong>. This method contains a <code>match</code> statement on the generated <code>WorkItem</code> enum. Each arm corresponds to a Node in your workflow. Inside the arm, it:<ul>
<li>Calls the actual <code>process</code> method of the corresponding Node instance (e.g., <code>self.add_prefix.process(...)</code>).</li>
<li>Examines the returned <a href="../01__transition__enum_/"><code>Transition</code></a>.</li>
<li>Based on the <code>Transition</code> and your <code>edges</code> definition, it creates the <em>next</em> <code>WorkItem</code>(s) (e.g., <code>TextProcessorWorkItem::Capitalize(...)</code>) and pushes them onto the work queue (<code>__q</code>) provided to it.</li>
<li>If a terminal node finishes, it returns <code>Ok(Some(output))</code>. Otherwise, it returns <code>Ok(None)</code>.</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>Here's a simplified look at the generated <code>process_work_item</code> logic for our example:</p>
<div class="language-rust highlight"><pre><span></span><code><span id="__span-4-1"><span class="c1">// Simplified generated code for process_work_item (conceptual)</span>
</span><span id="__span-4-2"><span class="k">async</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">_process_work_item</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="o">&gt;</span><span class="p">(</span>
</span><span id="__span-4-3"><span class="w">    </span><span class="o">&amp;&#39;</span><span class="na">a</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span>
</span><span id="__span-4-4"><span class="w">    </span><span class="n">ctx</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span><span class="w"> </span><span class="nc">floxide_core</span><span class="p">::</span><span class="n">WorkflowCtx</span><span class="o">&lt;</span><span class="n">SimpleContext</span><span class="o">&gt;</span><span class="p">,</span>
</span><span id="__span-4-5"><span class="w">    </span><span class="n">item</span><span class="p">:</span><span class="w"> </span><span class="nc">TextProcessorWorkItem</span><span class="p">,</span><span class="w"> </span><span class="c1">// Input is the generated enum</span>
</span><span id="__span-4-6"><span class="w">    </span><span class="n">__q</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">collections</span><span class="p">::</span><span class="n">VecDeque</span><span class="o">&lt;</span><span class="n">TextProcessorWorkItem</span><span class="o">&gt;</span><span class="w"> </span><span class="c1">// Output queue</span>
</span><span id="__span-4-7"><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">floxide_core</span><span class="p">::</span><span class="n">error</span><span class="p">::</span><span class="n">FloxideError</span><span class="o">&gt;</span>
</span><span id="__span-4-8"><span class="p">{</span>
</span><span id="__span-4-9"><span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">floxide_core</span><span class="p">::</span><span class="n">transition</span><span class="p">::</span><span class="n">Transition</span><span class="p">;</span>
</span><span id="__span-4-10"><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="p">{</span>
</span><span id="__span-4-11"><span class="w">        </span><span class="n">TextProcessorWorkItem</span><span class="p">::</span><span class="n">AddPrefix</span><span class="p">(</span><span class="n">input_string</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
</span><span id="__span-4-12"><span class="w">            </span><span class="c1">// Call the actual node&#39;s process method</span>
</span><span id="__span-4-13"><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">transition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">add_prefix</span><span class="p">.</span><span class="n">process</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">.</span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="n">input_string</span><span class="p">).</span><span class="k">await</span><span class="o">?</span><span class="p">;</span>
</span><span id="__span-4-14"><span class="w">            </span><span class="k">match</span><span class="w"> </span><span class="n">transition</span><span class="w"> </span><span class="p">{</span>
</span><span id="__span-4-15"><span class="w">                </span><span class="n">Transition</span><span class="p">::</span><span class="n">Next</span><span class="p">(</span><span class="n">output_string</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
</span><span id="__span-4-16"><span class="w">                    </span><span class="c1">// Look up edges for add_prefix: finds [capitalize]</span>
</span><span id="__span-4-17"><span class="w">                    </span><span class="c1">// Create the next work item</span>
</span><span id="__span-4-18"><span class="w">                    </span><span class="kd">let</span><span class="w"> </span><span class="n">next_item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TextProcessorWorkItem</span><span class="p">::</span><span class="n">Capitalize</span><span class="p">(</span><span class="n">output_string</span><span class="p">);</span>
</span><span id="__span-4-19"><span class="w">                    </span><span class="c1">// Add it to the queue</span>
</span><span id="__span-4-20"><span class="w">                    </span><span class="n">__q</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">next_item</span><span class="p">);</span>
</span><span id="__span-4-21"><span class="w">                    </span><span class="nb">Ok</span><span class="p">(</span><span class="nb">None</span><span class="p">)</span><span class="w"> </span><span class="c1">// More work to do</span>
</span><span id="__span-4-22"><span class="w">                </span><span class="p">}</span>
</span><span id="__span-4-23"><span class="w">                </span><span class="n">Transition</span><span class="p">::</span><span class="n">NextAll</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* Handle fan-out similarly */</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="nb">None</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
</span><span id="__span-4-24"><span class="w">                </span><span class="n">Transition</span><span class="p">::</span><span class="n">Abort</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">),</span>
</span><span id="__span-4-25"><span class="w">                </span><span class="n">Transition</span><span class="p">::</span><span class="n">Hold</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="nb">None</span><span class="p">),</span><span class="w"> </span><span class="c1">// Do nothing for Hold</span>
</span><span id="__span-4-26"><span class="w">            </span><span class="p">}</span>
</span><span id="__span-4-27"><span class="w">        </span><span class="p">}</span>
</span><span id="__span-4-28"><span class="w">        </span><span class="n">TextProcessorWorkItem</span><span class="p">::</span><span class="n">Capitalize</span><span class="p">(</span><span class="n">input_string</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
</span><span id="__span-4-29"><span class="w">            </span><span class="c1">// Call the actual node&#39;s process method</span>
</span><span id="__span-4-30"><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">transition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">capitalize</span><span class="p">.</span><span class="n">process</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">.</span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="n">input_string</span><span class="p">).</span><span class="k">await</span><span class="o">?</span><span class="p">;</span>
</span><span id="__span-4-31"><span class="w">            </span><span class="k">match</span><span class="w"> </span><span class="n">transition</span><span class="w"> </span><span class="p">{</span>
</span><span id="__span-4-32"><span class="w">                </span><span class="n">Transition</span><span class="p">::</span><span class="n">Next</span><span class="p">(</span><span class="n">output_string</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
</span><span id="__span-4-33"><span class="w">                    </span><span class="c1">// Look up edges for capitalize: finds [] (terminal)</span>
</span><span id="__span-4-34"><span class="w">                    </span><span class="c1">// Return the final output</span>
</span><span id="__span-4-35"><span class="w">                    </span><span class="nb">Ok</span><span class="p">(</span><span class="nb">Some</span><span class="p">(</span><span class="n">output_string</span><span class="p">))</span>
</span><span id="__span-4-36"><span class="w">                </span><span class="p">}</span>
</span><span id="__span-4-37"><span class="w">                </span><span class="n">Transition</span><span class="p">::</span><span class="n">NextAll</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* Handle fan-out */</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="nb">None</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="c1">// Might still be terminal</span>
</span><span id="__span-4-38"><span class="w">                </span><span class="n">Transition</span><span class="p">::</span><span class="n">Abort</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">),</span>
</span><span id="__span-4-39"><span class="w">                </span><span class="n">Transition</span><span class="p">::</span><span class="n">Hold</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="nb">None</span><span class="p">),</span>
</span><span id="__span-4-40"><span class="w">            </span><span class="p">}</span>
</span><span id="__span-4-41"><span class="w">        </span><span class="p">}</span>
</span><span id="__span-4-42"><span class="w">    </span><span class="p">}</span>
</span><span id="__span-4-43"><span class="p">}</span>
</span></code></pre></div>
<p>This generated code directly translates your <code>edges</code> definition into the runtime logic that connects the Nodes.</p>
<p>Here's a sequence diagram showing how the engine uses the generated <code>process_work_item</code> method during a run:</p>
<div class="mermaid">sequenceDiagram
    participant Engine
    participant WorkflowImpl as TextProcessor Instance
    participant PrefixNode as self.add_prefix
    participant CapitalizeNode as self.capitalize
    participant Queue as Work Queue (__q)

    Note over Engine: Start run, initial item is AddPrefix("hello")
    Engine-&gt;&gt;WorkflowImpl: process_work_item(ctx, WorkItem::AddPrefix("hello"), queue)
    WorkflowImpl-&gt;&gt;PrefixNode: process(ctx.store, "hello")
    PrefixNode--&gt;&gt;WorkflowImpl: Return Ok(Transition::Next("INFO: hello"))
    WorkflowImpl-&gt;&gt;WorkflowImpl: Check edges for add_prefix -&gt; finds [capitalize]
    WorkflowImpl-&gt;&gt;Queue: Enqueue WorkItem::Capitalize("INFO: hello")
    WorkflowImpl--&gt;&gt;Engine: Return Ok(None) (more work pending)

    Note over Engine: Later, process next item from queue...
    Engine-&gt;&gt;WorkflowImpl: process_work_item(ctx, WorkItem::Capitalize("INFO: hello"), queue)
    WorkflowImpl-&gt;&gt;CapitalizeNode: process(ctx.store, "INFO: hello")
    CapitalizeNode--&gt;&gt;WorkflowImpl: Return Ok(Transition::Next("INFO: HELLO"))
    WorkflowImpl-&gt;&gt;WorkflowImpl: Check edges for capitalize -&gt; finds [] (terminal)
    WorkflowImpl--&gt;&gt;Engine: Return Ok(Some("INFO: HELLO")) (final output)
</div>
<p>The real implementation of the macro lives in <code>floxide-macros/src/workflow.rs</code> and the <code>Workflow</code> trait definition is in <code>floxide-core/src/workflow.rs</code>.</p>
<h2 id="conclusion">Conclusion<a class="headerlink" href="#conclusion" title="Permanent link">&para;</a></h2>
<p>The <code>Workflow</code> trait and the <code>workflow!</code> macro are central to defining the overall structure and execution flow in Floxide.</p>
<ul>
<li>A <code>Workflow</code> acts as the master blueprint, holding all <a href="../02__node__trait____node___macro_/"><code>Node</code>s</a> and defining their connections (edges).</li>
<li>The <code>Workflow</code> trait defines the standard interface for executing workflows in various modes (local, checkpointed, distributed).</li>
<li>The <code>workflow!</code> macro provides a convenient way to declare the workflow struct, its Nodes, the starting point, the shared <a href="../03__workflowctx_____context__trait_/"><code>Context</code></a>, and the crucial edge mappings.</li>
<li>The macro generates the necessary Rust code, including the <code>Workflow</code> trait implementation and the internal routing logic (<code>process_work_item</code>), which translates your high-level definition into executable steps.</li>
<li>This explicit definition of structure and edges is vital for enabling reliable <strong>distributed execution</strong>, as it provides the map the engine needs to route tasks across different workers via a shared work queue.</li>
</ul>
<p>Now that we have defined our Nodes, Context, and the overall Workflow structure, how does Floxide manage the list of tasks waiting to be executed, especially in a distributed environment? That's the role of the <code>WorkQueue</code>.</p>
<p><strong>Next:</strong> <a href="../05__workqueue__trait_/">Chapter 5: <code>WorkQueue</code> Trait</a></p>
</section>

            </main>
        </div>
        <hr><footer>
    <div class="terminal-mkdocs-footer-grid">
        <div id="terminal-mkdocs-footer-copyright-info">
             Site built with <a href="http://www.mkdocs.org">MkDocs</a> and <a href="https://github.com/ntno/mkdocs-terminal">Terminal for MkDocs</a>.
        </div>
    </div>
</footer>
    </div>

    
    <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="alertdialog" aria-modal="true" aria-labelledby="searchModalLabel">
    <div class="modal-dialog modal-lg" role="search">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="searchModalLabel">Search</h5>
                <button type="button" class="close btn btn-default btn-ghost" data-dismiss="modal"><span aria-hidden="true">x</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p id="searchInputLabel">Type to start searching</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" aria-labelledby="searchInputLabel" placeholder="" id="mkdocs-search-query" title="Please enter search terms here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No document matches found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>
    
    
</body>

</html>